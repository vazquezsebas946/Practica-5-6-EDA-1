#include "ejercicio03.h"    //INCLUYE EL ARCHIVO DE CABECERA TIPO H

#include <stdlib.h> //INCLUYE LA BIBIOTECA stdlib.h; PARA EL MANEJO DE LA MEMORIA DINÁMICA
#include <stdio.h>  //INCLUYE LA BIBIOTECA stdio.h; PARA LEER E IMPRIMIR DATOS DE TECLADO

nodo* crear_nodoC(INFO info, int priori)
{
    /* FUNCIÓN crear_nodoC PARA RESERVAR MEMORIA PARA UN NODO,
    PARÁMETROS: VARIABLE TIPO INFO; INFORMACIÓN DEL NODO, VARIABLE TIPO int; PRIORIDAD DEL NODO. RETORNA UN APUNTADOR TIPO nodo*/

    nodo *t=(nodo*)malloc(sizeof(nodo));    //DECLARA UNA VARIABLE APUNTADOR TIPO nodo Y RESERVA MEMORIA CON LA FUNCIÓN malloc
    t->sig=NULL;    //IGUALA EL APUNTADOR AL NODO SIGUIENTE A NULO;
    t->info=info;   //IGUALA LA INFORMACIÓN DEL NODO AL PARÁMETRO QUE RECIVE LA INFORMACIÓN
    t->prioridad=priori;    //IGUALA EL CAMPO PRIORIDAD AL PARÁMETRO QUE RECIVE LA FUNCIÓN
    return t;   //RETORNA EL APUNTADOR DEL NODO
}

void liberar_nodoC(nodo *n) //FUNCIÓN liberar_nodoC PARA LIBERAR MEMORIA DE UN NODO. PARÁMETROS: APUNTADOR TIPO nodo
{
    if(n->sig==NULL)    //CONDICIÓN PARA LIBERAR MEMORIA DEL NODO;
    {
        free(n);    //FUNCIÓN FREE PARA LIBERAR LA MEMORIA DEL NODO
        n=NULL; //LA VARIBLE APUNTA A NULO
    }
}

cola* crear_cola()  //FUNCIÓN crear_cola PARA CREAR/RESERVAR MEMORIA DE UNA cola
{
    cola *l=(cola*)malloc(sizeof(cola));    //RESERVA MEMORIA PARA LA VARIABLE APUNTADOR TIPO cola CON LA FUCIÓN malloc
    l->head=l->tail=NULL;   //APUNTA LOS APUNTADORES DE LA CABEZA Y LA COLA DE LA COLA A NULO
    l->num=0;   //IGULA EL CONTADOR DE LA COLA A CERO; INICIA EL CONTADOR EN CERO
    return l;   //RETORNA EL APUNTADOR DE LA COLA
}

void liberar_cola(cola *l)  //FUNCIÓN liberar_cola PARA LIBERAR MEMORIA DE LA COLA, PARÁMETROS: VARIABLE APUNTADOR TIPO cola; APUNTADOR A LA COLA
{
    if(l==NULL) return; //RETORNA NULO EN CASO DE QUE LA PILA NO EXISTA
    if(!es_vaciaC(l))   //CONDICIÓN PARA DETERMINAR SI LA COLA NO ESTÁ VACÍA
        vaciarC(l); //LLAMA A LA FUNCIÓN vaciasC PARA VACIAR LA COLA
    free(l);    //LLAMA A LA FUNCIÓN free PARA LIBERAR LA MEMORIA RESERVADA PARA LA COLA
    l=NULL; //APUNTA A NULO LA VARIBALE DE LA COLA

}

bool insertar_inicio(cola *l, INFO info, int priori)
{
    /*FUNCIÓN insertar_inicio PARA INSERTAR UN NODO AL INICIO DE LA COLA,
    PARÁMETROS: VARIBALE APUNTADOR TIPO cola; APUNTADOR A LA COLA, VARIABLE TIPO INFO, INFORMACIÓN DE NODO, VARIABLE TIPO int; PRIORIDAD*/

    nodo* nuevo=crear_nodoC(info,priori);   //DECLARA Y CREA UN NODO NUEVO CON LA FUNCIÓN crear_nodo
    if(l->head == NULL && l->tail==NULL)    //CONDICIÓN PARA INSERTAR SI LA COLA ESTA VACÍA, EL APUNTADOR A CABEZA Y LA COLA APUNTAN A NULO
    {
        l->head=l->tail=nuevo;  //LOS APUNTADORES A LA CABEZA Y COLA DE LA PILA APUNTAN AL NUEVO Y ÚNICO NODO
        l->num++;   //AUMENTA EL CONTADOR DE NODOS DE LA COLA EN UNO
        return true;    //TERMINA LA FUNCIÓN HABIENDO INSERTADO UN NODO, RETORNA TRUE
    }
    else    //EXISTE ALMENOS UN NODO EN LA PILA
    {
        nuevo->sig=l->head; //IGUALA EL APUNTADOR AL SIGUIENTE NODO DE NUEVO A LA CABEZA
        l->head=nuevo;  //IGUALA LA CABEZA AL NODO NUEVO
        l->num++;   //AUMENTA EL CONTADOR DE NODOS DE LA COLA EN UNO
        return true;    //TERMINA LA FUNCIÓN HABIENDO INSERTADO UN NODO, RETORNA TRUE
    }
    return false;   //RETORNA FALSE EN CASO DE NO CUMPLIR ALGUNA DE LAS CONDICIONES ANTERIORES
}

bool insertar_final(cola *l, INFO info, int priori)
{
    /*FUNCIÓN insertar_final PARA INSERTAR UN NODO AL FINAL DE LA COLA,
    PARÁMETROS: VARIBALE APUNTADOR TIPO cola; APUNTADOR A LA COLA, VARIABLE TIPO INFO, INFORMACIÓN DE NODO, VARIABLE TIPO int; PRIORIDAD*/

    nodo* nuevo=crear_nodoC(info,priori);   //DECLARA Y CREA UN NODO NUEVO CON LA FUNCIÓN crear_nodo
    if(l->head == NULL && l->tail==NULL)    //CONDICIÓN PARA INSERTAR SI LA COLA ESTA VACÍA, EL APUNTADOR A CABEZA Y LA COLA APUNTAN A NULO
    {
        l->head=l->tail=nuevo;  //LOS APUNTADORES A LA CABEZA Y COLA DE LA PILA APUNTAN AL NUEVO Y ÚNICO NODO
        l->num++;   //AUMENTA EL CONTADOR DE NODOS DE LA COLA EN UNO
        return true;    //TERMINA LA FUNCIÓN HABIENDO INSERTADO UN NODO, RETORNA TRUE
    }
    else    //EXISTE ALMENOS UN NODO EN LA PILA
    {
        l->tail->sig=nuevo; //IGUALA EL APUNTADOR AL SIGUIENTE NODO DE LA COLA AL NUEVO NODO
        l->tail=nuevo;  //IGUALA LA COLA AL NUEVO NODO
        l->num++;   //AUMENTA EL CONTADOR DE NODOS DE LA COLA EN UNO
        return true;//TERMINA LA FUNCIÓN HABIENDO INSERTADO UN NODO, RETORNA TRUE
    }
    return false;   //RETORNA FALSE EN CASO DE NO CUMPLIR ALGUNA DE LAS CONDICIONES ANTERIORES
}

void prioridad(cola *l, INFO valor, int prio)
{
    /*FUNCIÓN prioridad PARA DETERMINAR SI SE INSERTA AL INICIO O AL FINAL,
    PARÁMETROS: VARIABLE APUNTADOR TIPO cola; APUNTADOR A LA COLA, VARIBALE TIPO INDO; INFORMACIÓN DEL NODO, VARIABLE TIPO int; PRIORIDAD*/
    int cont=0;
    nodo *temporal=l->head; //DECLARA E IGUALA UN APUNTADOR TEMPORAL Y LO IGUALA A LA CABEZA
    while(temporal!=NULL)   //CICLO WHILE; RECORRE TODOS LOS NODOS DE LA COLA
    {
        if(prio > temporal->prioridad)  //COMPARA LAS PRIORIDADES
            cont++; //AUMENTA EL CONTADOR EN UNO
        temporal=temporal->sig; //RECORRE EL APUNTADOR TEMPORAL AL SIGUIENTE NODO
    }
    if(cont==l->num) return insertar_inicio(l, valor, prio);    //CONDICIÓN PARA INSERTAR AL INICIO; LA PRIORIDAD TIENE QUE SER MAYOR A TODOS LOS NODOS
    return insertar_final(l, valor, prio);  //INSERTAR AL FINAL SI LA PRIORIDAD NO ES MAYOR A TODOS LOS NODOS

}

void dequeue(cola *l)   //FUNCIÓN pop PARA ELIMINAR EL ÚLTIMO NODO DE LA COLA, PARÁMETROS: VARIABLE APUNTADOR TIPO cola, APUNTADOR A LA COLA
{
    if(es_vaciaC(l)) return; //CONDICIÓN PARA RETORNAR EL CONTROL A LA FUNCIÓN QUE LA MANDO LLAMAR SI LA COLA ESTÁ VACÍA; NO ELIMINA
    nodo* temporal=l->head; //DECLARA Y CREA UN NODO TEMPORAL Y LO IGUALA A LA CABEZA DE LA COLA
    l->head=l->head->sig;   //IGUALA LA CABEZA AL APUNTADOR AL SIGUIENTE NODO DE LA CABEZA; RECORRE LA CABEZA AL SIGUIENTE NODO
    temporal->sig=NULL; //IGUALA EL APUNTADOR AL SIGUIENTE NODO DE TEMPORAL A NULO
    liberar_nodoC(temporal);    //LLAMA A LA FUNCIÓN liberar_nodoC PARA LIBERAR MEMORIA DE TEMPORAL
    l->num--;   //DECREMENTA EL CONTADOR DE NODOS DE LA COLA EN UNO
}

INFO* colaC(cola *l)
{
    /*FUNCIÓN colaC PARA RETORNAR LA DIRECCIÓN DE MEMORIA DE LA INFORMACIÓN ÚLTIMO NODO DE LA COLA,
    PARÁMETROS: APUNTADOR TIPO cola; APUNTADOR A LA COLA*/

    if(es_vaciaC(l)) return NULL;   //CONDICIÓN PARA RETORNAR NULO SI LA COLA ESTÁ VACÍA
    else return &l->tail->info; //RETONA LA DIRECCIÓN DE LA INFORMACIÓN DEL NODO SUPERIOR DE LA COLA
}

bool es_vaciaC(cola *l) //FUNCIÓN es_vacia PARA DETERMINAR SI LA COLA ESTÁ VACÍA, PARÁMETROS: VARIABLE APUNTADOR TIPO cola; APUNTADOR A LA COLA
{
    if(l->head == NULL && l->tail == NULL) return true; /*CONDICÓN PARA DETERMINAR SI LA LISTA ESTÁ VACÍA,
    LOS APUTNADORES DE LA CABEZA Y COLA TIENEN QUE APUNTAR A NULO, RETORNA TRUE*/
    return false;   //RETORNA FALSE EN CASO DE QUE LA LISTA NO ESTÉ VACÍA
}

bool vaciarC(cola *l)
{
    /*FUNCIÓN vaciarC PARA VACIAR LA COLA,
    PARÁMETROS: VARIABLE APUNTADOR TIPO cola; APUNTADOR A LA COLA, ELIMINA DEL PRIMER AL ÚLTIMO NODO*/

    if(es_vaciaC(l)) return false;  //CONDICIÓN PARA RETORNAR FALSE EN CASO DE QUE LA LISTA ESTÉ VACÍA
    nodo *temporal=l->head; //DECLARA UN APUNTADOR TIPO nodo TEMPORAL Y LA IGUALA A LA CABEZA DE LA COLA
    while(temporal != NULL) //CICLO WHILE, SE REPITE HASTA QUE LA VARIABLE TEMPORAL SEA IGUAL A NULO
    {
        l->head=temporal->sig;  //IGUALA EL APUNTDO DE LA CABEZA AL APUNTADOR AL SIGUIENTE NODO DE TEMPORAL, RECORRE LA CABEZA AL SIGUIENTE NODO
        temporal->sig=NULL; //IGUALA EL APUTNADOR AL SIGUIENTE NODO DE TEMPORAL A NULO, CONDICIÓN PARA LIBERAR MEMORIA DEL NODO
        liberar_nodoC(temporal); //LLAMA A LA FUNCIÓN liberar_nodo PARA LIBERAR LA MEMORIA DE TEMPORAL
        temporal=l->head;   //IGUALA TEMPORAL A LA CABEZA
    }
    l->head=l->tail=NULL;   //IGUALA LOS APUNTADORES DE CABEZA Y COLA A NULO
    l->num=0;   //IGUALA EL CONTADOR DE NODOS DE LA LISTA A CERO
    return true;    //RETORNA TRUE, LA COLA SE VACIÓ
}

void imprimir_cola(cola *l) //FUNCIÓN imprimir_cola PARA IMPRIMIR LA COLA, PARÁMTROS: VARIABLE APUNTADOR TIPO cola; APUNTADOR A LA COLA
{
    if(es_vaciaC(l))    //CONDICIÓN PARA EJECUTAR EL BLOQUE EN CASO DE QUE LA COLA ESTÉ VACÍA
    {
        printf("COLA VACIA\n"); //MANDA UN MENSAJE AL USUARIO
        return; //TERMINA LA FUNCIÓN
    }
    if(l == NULL)
    {
        printf("LA COLA NO EXISTE\n");  //MANDA UN MENSAJE AL USUARIO
        return; //TERMINA LA FUNCIÓN
    }

    nodo* t=NULL;  //DECLARA UNA VARIABLE APUNTADOR TIPO nodo Y LA IGUALA A NULO
    for(t=l->head; t != NULL; t=t->sig) //CICLO FOR PARA RECORRER CADA NODO DE INICIO A FIN
    {
        printf("<--%d(%d) ", t->info,t->prioridad); //IMPRIME LA INFORMACIÓN DEL NODO
    }
    printf("\n\n"); //IMPRIME UN SALTO DE LÍNEA
    return; //TERMINA LA FUNCIÓN

}

int main()  //FUNCIÓN PRINCIPAL
{
    cola *c1=crear_cola();  //CREA UNA VARIABLE APUNTADOR TIPO cola CON LA FUNCIÓN crear_cola
    prioridad(c1,4,3);  //INSERTA UN NODO CON VALOR 4 Y PRIORIDAD 3
    imprimir_cola(c1);  //IMPRIME LA COLA
    prioridad(c1,6,1);  //INSERTA UN NODO CON VALOR 4 Y PRIORIDAD 3
    imprimir_cola(c1);  //IMPRIME LA COLA
    prioridad(c1,38,55);    //INSERTA UN NODO CON VALOR 4 Y PRIORIDAD 3
    imprimir_cola(c1);  //IMPRIME LA COLA
    prioridad(c1,44,7); //INSERTA UN NODO CON VALOR 4 Y PRIORIDAD 3
    imprimir_cola(c1);  //IMPRIME LA COLA
    prioridad(c1,38,8); //INSERTA UN NODO CON VALOR 4 Y PRIORIDAD 3
    imprimir_cola(c1);  //IMPRIME LA COLA
    prioridad(c1,100,56);   //INSERTA UN NODO CON VALOR 4 Y PRIORIDAD 3
    imprimir_cola(c1);  //IMPRIME LA COLA
    prioridad(c1,57,56);    //INSERTA UN NODO CON VALOR 4 Y PRIORIDAD 3
    imprimir_cola(c1);  //IMPRIME LA COLA

    dequeue(c1);    //ELIMINA EL ÚLTIMO NODO DE LA COLA
    imprimir_cola(c1);  //IMPRIME LA COLA

    vaciarC(c1);    //LLAMA A LA FUNCIÓN vaciarC PARA ELIMINAR TODOS LOS NODOS DE LA COLA
    imprimir_cola(c1);  //IMPRIME LA COLA

    free(c1);   //LIBERA MEMORIA DE LA VARIABLE RESERVADA PARA LA COLA
    c1=NULL;    //IGUALA LA VARIABLE A NULO
    return 0;   //TERMINA EL PROGRAMA
}
