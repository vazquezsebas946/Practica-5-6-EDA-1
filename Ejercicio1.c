#include "Ejercicio2.h" //ARCHIVO DE CABECERA
#include <stdlib.h> //BIBLIOTECA PARA LA MEMORIA DINÁMICA
#include <stdio.h>  //BIBLIOTECA PARA IMPRIMIR Y LEER

NODO* crearNodo(DATO n) //FUNCIÓN crearNodo PARA CREAR UN NODO, PARÁMETROS: VARIABLE TIPO DATO;INFORMACIÓN DEL NODO,
{
    NODO *b=(NODO*)malloc(sizeof(NODO));    //RESERVA MEMORIA PARA UN NODO CON LA FUNCIÓN MALLOC
    b->info=n;  //LA INFORMACIÓN DEL NODO SE IGUALA A LA INFORMACIÓN RECIVIDA DEL PARÁMETRO DE LA FUNCIÓN
    b->siguiente=b->anterior=NULL;  //LOS APUNTADOR Al SIGUIENTE Y ANTERIOR NODO  SE IGUALAN A NULO
    return b;   //RETORNA EL APUNTADOR DEL NODO
}

void liberarNodo(NODO *n)   //FUNCIÓN liberarNodo PARA LIBERAR UN NODO, PARÁMETRO: VARIABLE APUNTADOR TIPO NODO; APUNTADOR DEL NODO
{
    if(n->anterior==NULL && n->siguiente==NULL) //CONDICIÓN PARA LIBERAR MEMORIA DEL NODO, APUNTADOR AL NODO SIGUIENTE Y ANTERIOR DEL NODO TIENEN QUE APUNTAR A NULO
    {
        free(n);    //FUNCIÓN FREE PARA LIBERAR LA MEMORIA DEL NODO
        n=NULL; //LA VARIBLE APUNTA A NULO
    }
}

BICOLADL* crearBicolaDL() //FUNCIÓN crearBicolaDL PARA CREAR LA BICOLA
{
    BICOLADL *l=(BICOLADL*)malloc(sizeof(BICOLADL));   //RESERVA MEMORIA PARA LA VARIABLE APUNTADOR TIPO BICOLADL CON LA FUCIÓN MALLOC
    l->head=l->tail=NULL;   //APUNTA EL APUNTADOR DE LA CABEZA Y LA COLA DE LA BICOLA A NULO
    l->num=0;   //IGULA EL CONTADOR DE LA BICOLA A CERO
    return l;   //RETORNA EL APUNTADOR DE LA BICOLA
}

void liberarBicolaDL(BICOLADL *l)  //FUNCIÓN liberarBicolaDL PARA LIBERAR LA BICOLA, PARÁMETROS: VARIABLE APUNTADOR TIPO BICOLADL; APUNTADOR A LA BICOLA
{
    if(esVaciaDL(l)==false) //CONDICIONAL PARA DETERMINAR SI LA BICOLA NO ESTÁ VACÍA
        vaciarBicolaDL(l);   //LLAMA A LA FUNCIÓN vaciarBicolaDL PARA VACIAR LA BICOLA

    free(l);    //LIBERA LA MEMORIA RESERVADA DE LA VARIABLE BICOLA
    l=NULL; //APUNTA A NULO LA VARIABLE DE LA BICOLA
}

bool insertarInicioDL(BICOLADL *l, DATO n)
{
    /*FUNCIÓN insertarInicioDL PARA INSERTAR UN NODO AL INICIO,
        PARÁMETROS: VARIBALE APUNTADOR TIPO BICOLADL; APUNTADOR A LA BICOLA, VARIABLE TIPO DATO, INFORMACIÓN DE NODO*/

    NODO *nuevo=crearNodo(n);   //DECLARA Y CREA UN NODO NUEVO CON LA FUNCIÓN crearNodo
    if(l->head == NULL && l->tail == NULL)  //CONDICIÓN PARA INSERTAR SI LA BICOLA ESTÁ VACÍA, EL APUNTADOR A LA CABEZA Y LA COLA APUNTAN A NULO
    {
        l->head=l->tail=nuevo;  //IGUALA LOS APUNTADORES DE LA CABEZA Y COLA DE LA BICOLA AL NUEVO Y ÚNICO NODO
        l->num++;   //AUMENTA EL CONTADOR DE NODOS DE LA LISTA EN UNO
        return true;    //TERMINA LA FUNCIÓN HABIENDO INSERTADO UN NODO, RETORNA TRUE
    }
    if(l->head!=NULL && l->tail!=NULL)  //CONDICIÓN DE QUE EXISTE ALMENOS UN NODO EN LA BICOLA, APUNTADORES A LA CABEZA Y COLA NO APUNTAN A NULO
    {
        nuevo->siguiente=l->head;   //IGUALA EL APUNTADOR AL SIGUIENTE NODO DE NUEVO A LA CABEZA
        l->head->anterior=nuevo;    //IGUALA EL APUNTADOR AL ANTERIOR NODO DE LA CABEZA A NUEVO
        l->head=nuevo;  //IGUALA LA CABEZA A NUEVO; RECORRE LA CABEZA AL NUEVO NODO
        l->num++;   //AUMENTA EL CONTADOR DE NODOS DE LA BICOLA EN UNO
        return true;    //TERMINA LA FUNCIÓN HABIENDO INSERTADO UN NODO, RETORNA TRUE
    }
    return false;   //RETORNA FALSE EN CASO DE NO CUMPLIR ALGUNA DE LAS CONDICIONES ANTERIORES
}

bool insertarFinalDL(BICOLADL *l, DATO n)
{
    /*FUNCIÓN insertarFinalDL PARA INSERTAR UN NODO AL FINAL,
    PARÁMETROS: VARIBALE APUNTADOR TIPO BICOLADL; APUNTADOR A LA BICOLA, VARIABLE TIPO DATO, INFORMACIÓN DE NODO*/

    NODO *nuevo=crearNodo(n);   //DECLARA Y CREA UN NODO NUEVO CON LA FUNCIÓN crearNodo
    if(l->head == NULL && l->tail == NULL)  //CONDICIÓN PARA INSERTAR SI LA BICOLA ESTA VACIA, EL APUNTADOR A CABEZA Y LA COLA APUNTAN A NULO
    {
        l->head=l->tail=nuevo;  //LOS APUNTADORES A LA CABEZA Y COLA DE LA BICOLA APUNTAN AL NUEVO Y ÚNICO NODO
        l->num++;   //AUMENTA EL CONTADOR DE NODOS DE LA BICOLA EN UNO
        return true;    //TERMINA LA FUNCIÓN HABIENDO INSERTADO UN NODO, RETORNA TRUE
    }
    if(l->head != NULL && l->tail != NULL)  //CONDICIÓN DE QUE EXISTE ALMENOS UN NODO EN LA BICOLA, APUNTADORES A LA CABEZA Y COLA NO APUNTAN A NULO
    {
        l->tail->siguiente=nuevo;   //IGUALA EL APUNTADOR AL NODO SIGUIENTE DE LA COLA AL NODO NUEVO
        nuevo->anterior=l->tail;    //IGUALA EL APUNTADOR AL NODO ANTERIOR DE NUEVO A LA COLA
        l->tail=nuevo;  //IGUALA LA COLA AL NODO NUEVO; RECORRE LA COLA
        l->num++;   //AUMENTA EL CONTADOR DE NODOS DE LA BICOLA EN UNO
        return true;    //TERMINA LA FUNCIÓN HABIENDO INSERTADO UN NODO, RETORNA TRUE
    }
    return false;   //RETORNA FALSE EN CASO DE NO CUMPLIR ALGUNA DE LAS CONDICIONES ANTERIORES
}

void eliminarInicioDL(BICOLADL *l)
{
    /*FUNCIÓN eliminarInicioDL PATA ELIMINAR EL PRIMER NODO DE LA BICOLA,
     PARÁMETROS: VARIABLE APUNTADOR TIPO BICOLADL, APUNTADOR A LA BICOLA*/

    if(esVaciaDL(l)) return;    //CONDICIÓN PARA RETORNAR EL CONTROL A LA FUNCIÓN QUE LA MANDO LLAMAR SI LA BICOLA ESTÁ VACÍA
    l->head=l->head->siguiente; //IGUALA LA CABEZA AL APUNTADOR QUE APUNTA AL SIGUIENTE NODO DE LA CABEZA; RECORRE LA CABEZA AL SIGUIENTE NODO
    l->head->anterior->siguiente=NULL;  //IGUALA EL APUNTADOR AL ANTERIOR NODO DE LA CABEZA QUE ESTA APUNTADO AL NODO SIGUIENTE A NULO; CONDICION PARA LIBERAR LA MEMORIA DEL NODO
    liberarNodo(l->head->anterior); //LLAMA A LA FUNCIÓN liberarNodo PARA LIBERAR AL NODO QUE APUNTA AL ANTERIOR NODO DE LA CABEZA
    l->head->anterior=NULL; //IGUALA EL APUNTADOR AL NODO ANTERIOR DE LA CABEZA A NULO
    l->num--;   //DECREMENTA EL CONTADOR DE NODOS DE LA BICOLA EN UNO
}

void eliminarFinalDL(BICOLADL *l)    //FUNCIÓN ELIMINAR EL ÚLTIMO NODO DE LA BICOLA, PARÁMETROS: VARIABLE APUNTADOR TIPO BICOLADL, APUNTADOR A LA BICOLA
{
    if(esVaciaDL(l)) return;    //CONDICIÓN PARA RETORNAR EL CONTROL A LA FUNCIÓN QUE LA MANDO LLAMAR SI LA BICOLA ESTÁ VACÍA
    l->tail=l->tail->anterior;  //IGUALA LA COLA AL APUNTADOR AL ANTERIOR NODO DE LA COLA; RECORRE LA COLA UN NODO ATRÁS
    l->tail->siguiente->anterior=NULL;  //IGUALA EL APUNTADOR AL SIGUIENTE NODO QUE APUNTA AL ANTERIOR NODO A NULO; CONDICIÓN PARA LIBERAR EL NODO
    liberarNodo(l->tail->siguiente); //LLAMA A LA FUNCIÓN liberarNodo PARA LIBERAR AL NODO QUE APUNTA AL SIGUIENTE NODO DE LA COLA
    l->tail->siguiente=NULL;    //IGUALA EL APUNTADOR AL SIGUIENTE NODO DE LA COLA A NULO
    l->num--;   //DECREMENTA EL CONTADOR DE NODOS DE LA BICOLA EN UNO

}


bool esVaciaDL(BICOLADL *l)  //FUNCIÓN esVaciaDL PARA DETERMINAR SI LA BICOLA ESTÁ VACÍA, PARÁMETROS: VARIABLE APUNTADOR TIPO BICOLADL; APUNTADOR A LA BICOLA
{
    if(l->head==NULL && l->tail==NULL) return true; /*CONDICÓN PARA DETERMINAR SI LA BICOLA ESTÁ VACÍA,
    LOS APUTNADORES DE LA CABEZA Y COLA TIENEN QUE APUNTAR A NULO, RETORNA TRUE*/

    return false;   //RETORNA FALSE EN CASO DE QUE LA BICOLA NO ESTÉ VACÍA
}

bool vaciarBicolaDL(BICOLADL *l)  //FUNCIÓN vaciarListaDL PARA VACIAR LA VACIAR, PARÁMETROS: VARIABLE APUNTADOR TIPO BICOLADL; BICOLA, ELIMINA DEL PRIMER AL ÚLTIMO NODO
{

    if(esVaciaDL(l)) return false;  //CONDICIÓN PARA RETORNAR FALSE EN CASO DE BICOLA ESTÉ VACÍA
    NODO *tempo=l->head;    //DECLARA UN APUNTADOR TIPO NODO TEMPORAL Y LA IGUALA A LA CABEZA DE LA BICOLA

    while(tempo->siguiente != NULL) //CICLO WHILE, SE REPITE HASTA QUE EL APUNTADOR AL NODO SIGUIENTE SEA IGUAL A NULO
    {
        l->head=tempo->siguiente;   //IGUALA LA CABEZA AL APUNTADOR AL SIGUIENTE NODO DE TEMPORAL
        tempo->siguiente=NULL;  //IGUALA EL APUNTADOR AL SIGUIENTE NODO DE TEMPORAL A NULO
        l->head->anterior=NULL; //IGUALA EL APUNTADOR AL ANTERIOR NODO DE LA CABEZA A NULO; CONDICIONES PARA LIBERAR MEMORIA
        liberarNodo(tempo); //LLAMA A LA FUNCIÓN liberarNodo PARA LIBERAR A TEMPORAL
        tempo=l->head;  //IGUALA TEMPORAL A LA CABEZA
    }

    liberarNodo(tempo); //LLAMA A LA FUNCIÓN liberarNodo PARA LIBERAR A TEMPORAL
    l->head=l->tail=NULL;   //IGUALA LOS APUNTADORES DE CABEZA Y COLA A NULO
    l->num=0;   //IGUALA EL CONTADOR DE NODOS DE LA LISTA A CERO
    return true;    //RETORNA TRUE, LA BICOLA SE VACIÓ

}

DATO* recuperarCabeza(BICOLADL *l)
{
    /*FUNCIÓN recuperarCabeza PARA RECUPERAR LA DIRECCIÓN DE MEMORIA DE LA INFORMACIÓN DE LA CABEZA
    PARÁMETROS; VARIABLE APUNTADOR TIPO BICOLADL; APUNTADOR A LA BICOLADL*/

    if(esVaciaDL(l)) return NULL;   //CONDICIÓN PARA RETORNAR NULO EN CASO DE QUE LA BICOLA ESTÉ VACÍA
    return &l->head->info; //CONDICÓN PARA RETORNAR LA DIRECCIÓN DE LA INFORMACIÓN DEL PRIMER NODO
}

DATO* recuperarCola(BICOLADL *l)
{
    /*FUNCIÓN recuperarCabeza PARA RECUPERAR LA DIRECCIÓN DE MEMORIA DE LA INFORMACIÓN DE LA CABEZA
    PARÁMETROS; VARIABLE APUNTADOR TIPO BICOLADL; APUNTADOR A LA BICOLADL*/

    if(esVaciaDL(l)) return NULL;   //CONDICIÓN PARA RETORNAR NULO EN CASO DE QUE LA BICOLA ESTÉ VACÍA
    return &l->tail->info;  //CONDICIÓN PARA RETORNAR LA DIRECCIÓN DE LA INFORMACIÓN DEL ÚLTIMO NODO
}


void imprimirBicolaDL(BICOLADL *l)    //FUNCIÓN imprimirBicolaDL PARA IMPRIMIR BICOLA, PARÁMTROS: VARIABLE APUNTADOR TIPO BICOLADL; APUNTADOR A LA BICOLA
{
    int i;

    if(esVaciaDL(l))    //CONDICIÓN PARA EJECUTAR EL BLOQUE EN CASO DE QUE LA BICOLA ESTÉ VACÍA
    {
        printf("BICOLA VACIA...");   //MANDA UN MENSAJE AL USUARIO
        return; //TERMINA LA FUNCIÓN
    }
    if(l==NULL) //CODICIÓN PARA EJECUTAR EL BLOQUE EN CASO DE QUE LA BICOLA APUNTE A NULO, NO EXISTE LA BICOLA
    {
        printf("LA BICOLA NO EXISTE...");    //MANDA UN MENSAJE AL USUARIO
        return; //TERMINA LA FUNCIÓN
    }
    if(!esVaciaDL(l))   //CONDICIÓN PARA EJECUTAR EL BLOQUE EN CASO DE QUE LA BICOLA NO ESTÉ VACÍA
    {
        NODO* im=l->head;   //DECLARA UN APUTNADOR TIPO NODO TEMPORAL Y LO IGUALA A LA CABEZA

        for(i=0; i<=(l->num-1); i++)   //CICLO FOR; RECORRE TODOR LOS NODOS DE LA BICOLA
        {
            printf(" <-%d->", im->info);    //IMPRIME LA INFORMACIÓN DEL NODO
            im=im->siguiente;   //RECORRE EL NODO AL SIGUIENTE
        }
        printf("\n");   //IMPRIME UN SALTO DE LÍNEA
    }
}

int main()  //FUNCIÓN PRINCIPAL
{
    BICOLADL* B=crearBicolaDL();    //CREAR LA BICOLA
    printf("\tINSERTAR INICIO\n");  //MANDA UN MENSAJE
    insertarInicioDL(B,5);  //INSERTAR AL INICIO EL VALOR DE 5
    imprimirBicolaDL(B);    //IMPRIME LA BICOLA
    insertarInicioDL(B,44); //INSERTAR AL INICIO DE LA BICOLA EL VALOR DE 44
    imprimirBicolaDL(B);    //IMPRIME LA BICOLA
    insertarInicioDL(B,3);  //INSERTAR AL INICIO DE LA BICOLA EL VALOR DE 3
    imprimirBicolaDL(B);    //IMPRIME LA BICOLA
    insertarInicioDL(B,22); //INSERTAR AL INICIO DE LA BICOLA EL VALOR DE 22

    printf("\n\n\tINSERTAR FINAL\n");   //MANDA UN MENSAJE
    insertarFinalDL(B,66);  //INSERTAR AL FINAL EL VALOR DE 66
    imprimirBicolaDL(B);    //IMPRIME LA BICOLA
    insertarFinalDL(B,7);   //INSERTAR AL FINAL EL VALOR DE 7
    imprimirBicolaDL(B);    //IMPRIME LA BICOLA
    insertarFinalDL(B,88);  //INSERTAR AL FINAL EL VALOR DE 88
    imprimirBicolaDL(B);    //IMPRIME LA BICOLA

    printf("\n\n\tELIMINAR INICIO\n");  //MANDA UN MENSAJE
    eliminarInicioDL(B);    //ELIMINAR EL PRIMER NODO DE LA BICOLA
    imprimirBicolaDL(B);    //IMPRIME LA BICOLA

    printf("\n\n\tELIMINAR Final\n");   //MANDA UN MENSAJE
    eliminarFinalDL(B); //ELIMINAR ELTIMO NODO DE LA BICOLA
    imprimirBicolaDL(B);    //IMPRIME LA BICOLA

    printf("\n\n\tCABEZA DE LA BICOLA\n");  //MANDA UN MENSAJE
    imprimirBicolaDL(B);    //IMPRIME LA BICOLA
    DATO* cabeza=recuperarCabeza(B);    //DECLARA UNA VARIABLE APUNTADOR TIPO DATO Y LLAMA A LA FUNCIÓN recuperarCabeza
    printf("\nCabeza %d", *cabeza); //IMPRIME EL VALOR DE LA VARIABLE cabeza

    printf("\n\n\tCOLA DE LA BICOLA\n");    //MANDA UN MENSAJE
    imprimirBicolaDL(B);    //IMPRIME LA BICOLA
    DATO* cola=recuperarCola(B);    //DECLARA UNA VARIABLE APUNTADOR TIPO DATO Y LLAMA A LA FUNCIÓN recuperarCola
    printf("\nCola %d", *cola); //IMPRIME EL VALOR DE LA VARIABLE cola

    printf("\n\n\tVACIAR BICOLA\n"); //MANDA UN MENSAJE
    vaciarBicolaDL(B);  //LLAMA A LA FUNCIÓN vaciarBicolaDL PARA VACIAR LA BICOLA
    imprimirBicolaDL(B);    //IMPRIME LA BICOLA
    free(B);    //LIBERA MEMORIA DE LA VARIABLE BICOLA
    B=NULL; //APUNTA A NULO LA VARIABLE
    return 0;   //FIN DEL PROGRAMA
}

